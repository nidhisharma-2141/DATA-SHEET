# -*- coding: utf-8 -*-
"""sql-python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14cJV-7bOB7CyzbUKOaIrRGWSjwNBkn0x
"""

import sqlite3
conn=sqlite3.connect('sqlproject1.db')

conn.execute('''CREATE TABLE `customer1` (
`customer_id` varchar(10) ,
`name` varchar(100) NOT NULL,
`city` varchar(65) NOT NULL,
`email` varchar(45) NOT NULL,
`phone_no` varchar(15) NOT NULL,
`address` varchar(100) NOT NULL,
`pin_code` int NOT NULL,
PRIMARY KEY (`customer_id`)
) ;
''')
conn.commit()
print("student table created successfully ")

conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C001', 'John Doe', 'New York', 'john.doe@example.com', '123-456-7890', '123 Elm St', 10001);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C002', 'Jane Smith', 'Los Angeles', 'jane.smith@example.com', '234-567-8901', '456 Maple Ave', 90001);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C003', 'Alice Johnson', 'Chicago', 'alice.johnson@example.com', '345-678-9012', '789 Oak Dr', 60601);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C004', 'Bob Brown', 'Houston', 'bob.brown@example.com', '456-789-0123', '101 Pine Ln', 77001);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C005', 'Charlie Davis', 'Philadelphia', 'charlie.davis@example.com', '567-890-1234', '202 Cedar Blvd', 19101);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C006', 'Diana Evans', 'San Antonio', 'diana.evans@example.com', '678-901-2345', '303 Birch St', 78201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C007', 'Edward Harris', 'San Diego', 'edward.harris@example.com', '789-012-3456', '404 Walnut St', 92101);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C008', 'Fiona Wilson', 'Dallas', 'fiona.wilson@example.com', '890-123-4567', '505 Chestnut St', 75201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C009', 'George Clark', 'San Jose', 'george.clark@example.com', '901-234-5678', '606 Spruce St', 95101);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C010', 'Hannah Lewis', 'Austin', 'hannah.lewis@example.com', '012-345-6789', '707 Fir St', 73301);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C011', 'Isaac Young', 'Jacksonville', 'isaac.young@example.com', '123-456-7891', '808 Redwood St', 32201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C012', 'Julia Walker', 'San Francisco', 'julia.walker@example.com', '234-567-8902', '909 Palm Ave', 94101);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C013', 'Kevin Hall', 'Columbus', 'kevin.hall@example.com', '345-678-9013', '1010 Poplar St', 43201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C014', 'Laura Allen', 'Fort Worth', 'laura.allen@example.com', '456-789-0124', '1111 Ash St', 76101);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C015', 'Michael Scott', 'Indianapolis', 'michael.scott@example.com', '567-890-1235', '1212 Oakwood St', 46201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C016', 'Nora Scott', 'Charlotte', 'nora.scott@example.com', '678-901-2346', '1313 Maplewood St', 28201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C017', 'Oscar Adams', 'Seattle', 'oscar.adams@example.com', '789-012-3457', '1414 Hickory St', 98101);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C018', 'Paula Thompson', 'Denver', 'paula.thompson@example.com', '890-123-4568', '1515 Pinewood St', 80201);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C019', 'Quincy Martinez', 'Washington', 'quincy.martinez@example.com', '901-234-5679', '1616 Elmwood St', 20001);")
conn.execute("INSERT INTO customer1 (customer_id, name, city, email, phone_no, address, pin_code) VALUES('C020', 'Rachel Green', 'Boston', 'rachel.green@example.com', '012-345-6780', '1717 Cedarwood St', 02101); ")
conn.commit()

import sqlite3

# Connect to the database
conn = sqlite3.connect('sqlproject1.db')

# Create a cursor object
cursor = conn.cursor()

# Query to select all records from customer1 table
query = "SELECT * FROM customer1;"

# Execute the query
cursor.execute(query)

# Fetch all rows from the executed query
rows = cursor.fetchall()

# Print the rows
for row in rows:
    print(row)

# Close the connection
conn.close()

conn.execute(''' CREATE TABLE `product1` (
`product_id` varchar(10) ,
`product_name` varchar(100) NOT NULL,
`category` varchar(65) NOT NULL,
`sub_category` varchar(45) NOT NULL,
`original_price` double NOT NULL,
`selling_price` double NOT NULL,
`stock` int NOT NULL,
PRIMARY KEY (`product_id`)
);''')
conn.commit()
print("product table created successfully ")

result = conn.execute("SELECT product_id FROM product1")
existing_product_ids = [row[0] for row in result]
print(existing_product_ids)

conn.execute('''CREATE TABLE order_details1 (
`order_id` int PRIMARY KEY,
`customer_id` varchar(10) ,
`product_id` varchar(10) ,
`quantity` double NOT NULL,
`total_price` double NOT NULL,
`payment_mode` varchar(60) NOT NULL,
`order_date` datetime DEFAULT NULL,
`order_status` varchar(20) NOT NULL,
FOREIGN KEY (`customer_id`) REFERENCES `customer1` (`customer_id`),
FOREIGN KEY (`product_id`) REFERENCES `product1` (`product_id`)
);''')

conn.commit()
print("order_details table created successfully ")

result = conn.execute("SELECT order_id FROM order_details1")
existing_order_ids = [row[0] for row in result]
print(existing_order_ids)

conn.execute("INSERT INTO order_details1 (order_id, quantity, total_price, payment_mode, order_date, order_status) VALUES(34, 2, 220.00, 'PayPal', '2024-08-14 09:30:00', 'Shipped');")
conn.execute("INSERT INTO order_details1 (order_id,  quantity, total_price, payment_mode, order_date, order_status) VALUES(35, 1, 140.00, 'Credit Card', '2024-08-15 10:45:00', 'Completed');")
conn.execute("INSERT INTO order_details1 (order_id,  quantity, total_price, payment_mode, order_date, order_status) VALUES(36,  3, 375.00, 'Bank Transfer', '2024-08-16 12:00:00', 'Pending');")
conn.execute("INSERT INTO order_details1 (order_id,  quantity, total_price, payment_mode, order_date, order_status) VALUES(37,  2, 220.00, 'Debit Card', '2024-08-17 13:30:00', 'Delivered');")
conn.execute("INSERT INTO order_details1 (order_id,  quantity, total_price, payment_mode, order_date, order_status) VALUES(38,  1, 450.00, 'PayPal', '2024-08-18 14:45:00', 'Completed');")
conn.execute("INSERT INTO order_details1 (order_id,quantity, total_price, payment_mode, order_date, order_status) VALUES(39, 4, 275.00, 'Credit Card', '2024-08-19 15:30:00', 'Shipped');")
conn.execute("INSERT INTO order_details1 (order_id, quantity, total_price, payment_mode, order_date, order_status) VALUES(40, 2, 550.00, 'Bank Transfer', '2024-08-20 16:00:00', 'Pending');")

conn.commit()
print("20 records inserted into the order_details1 table successfully.")

"""## **Anayltics based on dataset**

# **Customer Analysis:**
# **Q1 Identify the total number of customers City wise.**
"""

import sqlite3
import csv

# Connect to your SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Create a cursor object
cursor = conn.cursor()

# Execute the query
cursor.execute('''
SELECT
    city AS region,
    COUNT(customer_id) AS customer_count
FROM
    customer1
GROUP BY
    city
ORDER BY
    customer_count DESC
''')

# Fetch the results using the cursor
rows = cursor.fetchall()

# Write results to a CSV file
with open('customer_region_counts.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['region', 'customer_count'])  # Header
    writer.writerows(rows)

print("Data exported to 'customer_region_counts.csv'")

# Close the connection
conn.close()

import pandas as pd
import matplotlib.pyplot as plt

# Load the data from CSV
data = pd.read_csv('customer_region_counts.csv')

# Create a bar chart
plt.figure(figsize=(12, 8))
plt.bar(data['region'], data['customer_count'], color='skyblue')
plt.xlabel('Region')
plt.ylabel('Number of Customers')
plt.title('Number of Customers Region Wise')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()

# Show the chart
plt.show()

"""# **Q2 Shows the count of customers using unique email domains**"""

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get unique email domains
query_unique_email_domains = '''
SELECT
    SUBSTR(email, INSTR(email, '@') + 1) AS email_domain,
    COUNT(customer_id) AS customer_count
FROM
    customer1
GROUP BY
    email_domain
ORDER BY
    customer_count DESC;
'''

# Load data into a DataFrame
df_unique_email_domains = pd.read_sql_query(query_unique_email_domains, conn)

# Close the connection
conn.close()

# Visualization: Bar chart for unique email domains distribution
plt.figure(figsize=(12, 8))
sns.barplot(x='customer_count', y='email_domain', data=df_unique_email_domains, palette='cool')
plt.xlabel('Number of Customers')
plt.ylabel('Email Domain')
plt.title('Customer Distribution by Unique Email Domains')
plt.show()



"""# **Q3 Displays the number of customers in each pin code area**"""

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get customer count by pin code
query_customer_by_pin_code = '''
SELECT
    pin_code,
    COUNT(customer_id) AS customer_count
FROM
    customer1
GROUP BY
    pin_code
ORDER BY
    customer_count DESC
LIMIT 10;  -- Limit to the top 10 pin codes for better visualization
'''

# Load data into a DataFrame
df_customer_by_pin_code = pd.read_sql_query(query_customer_by_pin_code, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_customer_by_pin_code.empty:
    # Visualization: Pie chart for customer count by pin code
    plt.figure(figsize=(10, 7))
    plt.pie(df_customer_by_pin_code['customer_count'],
            labels=df_customer_by_pin_code['pin_code'],
            autopct='%1.1f%%',
            startangle=140,
            colors=plt.get_cmap('Set2').colors)
    plt.title('Customer Count Distribution by Pin Code')
    plt.show()
else:
    print("No data available for customer count by pin code.")

"""# **Q4 Shows the average selling price of products in each category.**"""

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get average selling price by category
query_avg_selling_price_by_category = '''
SELECT
    category,
    AVG(selling_price) AS avg_selling_price
FROM
    product1
GROUP BY
    category
ORDER BY
    avg_selling_price DESC;
'''

# Load data into a DataFrame
df_avg_selling_price_by_category = pd.read_sql_query(query_avg_selling_price_by_category, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_avg_selling_price_by_category.empty:
    # Visualization: Pie chart for average selling price by category
    plt.figure(figsize=(10, 7))
    plt.pie(df_avg_selling_price_by_category['avg_selling_price'],
            labels=df_avg_selling_price_by_category['category'],
            autopct='%1.1f%%',
            startangle=140,
            colors=plt.get_cmap('tab20').colors)
    plt.title('Average Selling Price by Product Category')
    plt.show()
else:
    print("No data available for average selling price by category.")

"""# **Product Analysis:**
# Q5 Shows the top product categories based on total stock
"""

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get stock levels by category
query_stock_by_category = '''
SELECT
    category,
    SUM(stock) AS total_stock
FROM
    product1
GROUP BY
    category
ORDER BY
    total_stock DESC;
'''

# Load data into a DataFrame
df_stock_by_category = pd.read_sql_query(query_stock_by_category, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_stock_by_category.empty:
    # Visualization: Bar chart for stock by category
    plt.figure(figsize=(12, 8))
    sns.barplot(x='total_stock', y='category', data=df_stock_by_category, palette='cubehelix')
    plt.xlabel('Total Stock')
    plt.ylabel('Category')
    plt.title('Total Stock by Product Category')
    plt.show()
else:
    print("No data available for total stock by category.")

"""
# **Q6 Shows the stock levels of different products.**
"""

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get product stock levels
query_product_stock_levels = '''
SELECT
    product_name,
    stock
FROM
    product1
ORDER BY
    stock DESC
LIMIT 10;
'''

# Load data into a DataFrame
df_product_stock_levels = pd.read_sql_query(query_product_stock_levels, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_product_stock_levels.empty:
    # Visualization: Bar chart for product stock levels
    plt.figure(figsize=(12, 8))
    sns.barplot(x='stock', y='product_name', data=df_product_stock_levels, palette='inferno')
    plt.xlabel('Stock Level')
    plt.ylabel('Product Name')
    plt.title('Product Stock Levels')
    plt.show()
else:
    print("No data available for product stock levels.")

"""# **Q7-Determine the total number of products available by category**"""

import sqlite3
import csv

# Connect to your SQLite database
conn = sqlite3.connect('sqlproject1.db')
cursor = conn.cursor()

# Execute the query
cursor.execute('''
SELECT
    category,
    SUM(stock) AS total_products
FROM
    product1
GROUP BY
    category
ORDER BY
    total_products DESC
''')

# Fetch the results
rows = cursor.fetchall()

# Write results to a CSV file
with open('products_by_category.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['category', 'total_products'])  # Header
    writer.writerows(rows)

print("Data exported to 'products_by_category.csv'")

# Close the connection
conn.close()

import pandas as pd
import matplotlib.pyplot as plt

# Load the data from CSV
data = pd.read_csv('products_by_category.csv')

# Create a bar chart
plt.figure(figsize=(12, 8))
plt.bar(data['category'], data['total_products'], color='skyblue')
plt.xlabel('Category')
plt.ylabel('Total Number of Products')
plt.title('Total Number of Products Available by Category')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()

# Show the chart
plt.show()

"""# **Q8- Displays the average value of orders**"""

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to calculate average order value
query_avg_order_value = '''
SELECT
    AVG(total_price) AS avg_order_value
FROM
    order_details1;
'''

# Load data into a DataFrame
df_avg_order_value = pd.read_sql_query(query_avg_order_value, conn)

# Close the connection
conn.close()

# Visualization: Bar chart for average order value
plt.figure(figsize=(8, 6))
sns.barplot(x=['Average Order Value'], y=[df_avg_order_value['avg_order_value'].values[0]],
            palette='pastel')
plt.xlabel('Metric')
plt.ylabel('Value ($)')
plt.title('Average Order Value')
plt.ylim(0, df_avg_order_value['avg_order_value'].values[0] * 1.1)  # Add a bit of space above the bar
plt.show()

"""# Q9 distribution of products accross sub-categories"""

import pandas as pd
import matplotlib.pyplot as plt

# Load the data from CSV
data = pd.read_csv('products_by_sub_category.csv')

# Create a bar chart
plt.figure(figsize=(12, 8))
plt.bar(data['sub_category'], data['total_products'], color='lightgreen')
plt.xlabel('Sub-Category')
plt.ylabel('Total Number of Products')
plt.title('Distribution of Products Across Sub-Categories')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()

# Show the chart
plt.show()

"""# **Q10-  Displays the distribution of customer addresses by length..**"""

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get address lengths
query_address_length_distribution = '''
SELECT
    LENGTH(address) AS address_length,
    COUNT(customer_id) AS customer_count
FROM
    customer1
GROUP BY
    address_length
ORDER BY
    address_length;
'''

# Load data into a DataFrame
df_address_length_distribution = pd.read_sql_query(query_address_length_distribution, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_address_length_distribution.empty:
    # Visualization: Bar chart for address length distribution
    plt.figure(figsize=(12, 8))
    sns.barplot(x='address_length', y='customer_count', data=df_address_length_distribution, palette='plasma')
    plt.xlabel('Address Length')
    plt.ylabel('Number of Customers')
    plt.title('Customer Distribution by Address Length')
    plt.show()
else:
    print("No data available for address length distribution.")

"""# **Q11 Calculate the average, maximum, and minimum selling prices for products**

"""

import sqlite3
import csv

# Connect to your SQLite database
conn = sqlite3.connect('sqlproject1.db')
cursor = conn.cursor()

# Execute the query to calculate average, maximum, and minimum selling prices
cursor.execute('''
SELECT
    'Average Price' AS Price_Type,
    AVG(selling_price) AS Price
FROM
    product1
UNION ALL
SELECT
    'Maximum Price' AS Price_Type,
    MAX(selling_price) AS Price
FROM
    product1
UNION ALL
SELECT
    'Minimum Price' AS Price_Type,
    MIN(selling_price) AS Price
FROM
    product1;
''')

# Fetch the results
rows = cursor.fetchall()

# Write results to a CSV file
with open('price_summary.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['Price_Type', 'Price'])  # Header
    writer.writerows(rows)

print("Data exported to 'price_summary.csv'")

# Close the connection
conn.close()

import pandas as pd
import matplotlib.pyplot as plt

# Load the data from CSV
data = pd.read_csv('price_summary.csv')

# Create a pie chart
plt.figure(figsize=(8, 8))
plt.pie(data['Price'], labels=data['Price_Type'], autopct='%1.1f%%', colors=['skyblue', 'lightgreen', 'salmon'])
plt.title('Distribution of Average, Maximum, and Minimum Selling Prices')
plt.show()

"""# **Order Analysis:**
# **Q12 Visualize the top products with the lowset selling prices with database name as sqlproject1.**
"""

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get top products with the lowest selling prices
query_top_products_by_lowest_selling_price = '''
SELECT
    p.product_name,
    p.selling_price
FROM
    product1 p
ORDER BY
    p.selling_price ASC
LIMIT 10;
'''

# Load data into a DataFrame
df_top_products_by_lowest_selling_price = pd.read_sql_query(query_top_products_by_lowest_selling_price, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_top_products_by_lowest_selling_price.empty:
    # Visualization: Bar chart for top products by lowest selling price
    plt.figure(figsize=(12, 8))
    sns.barplot(x='selling_price', y='product_name', data=df_top_products_by_lowest_selling_price, palette='coolwarm')
    plt.xlabel('Selling Price')
    plt.ylabel('Product Name')
    plt.title('Top Products with Lowest Selling Prices')
    plt.show()
else:
    print("No data available for top products by lowest selling price.")

"""# **Q13 Analyze the order status distribution (e.g., pending, delivered).**"""

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Connect to the database
conn = sqlite3.connect('sqlproject1.db')

# SQL query to get order status distribution
query = '''
SELECT
    order_status,
    COUNT(*) AS status_count
FROM
    order_details1
GROUP BY
    order_status;
'''

# Load data into a DataFrame
df = pd.read_sql_query(query, conn)

# Close the connection
conn.close()

# Print DataFrame to see the data
print(df)

# Visualization: Bar chart
plt.figure(figsize=(10, 6))
sns.barplot(x='order_status', y='status_count', data=df)
plt.xlabel('Order Status')
plt.ylabel('Number of Orders')
plt.title('Order Status Distribution')
plt.show()

"""# **Q14 Visualize the top products with the highest selling prices..**"""

# Connect to the database
conn = sqlite3.connect('sqlproject1.db')

# Query to get top products by selling price
query_top_selling_price = '''
SELECT
    product_name,
    selling_price
FROM
    product1
ORDER BY
    selling_price DESC
LIMIT 10;
'''

df_top_selling_price = pd.read_sql_query(query_top_selling_price, conn)
conn.close()

# Horizontal bar chart for top selling prices
plt.figure(figsize=(12, 8))
sns.barplot(x='selling_price', y='product_name', data=df_top_selling_price, palette='plasma')
plt.xlabel('Selling Price')
plt.ylabel('Product Name')
plt.title('Top Products by Selling Price')
plt.show()

"""# **Q15 Visualize the difference between the original and selling prices for each product.**"""

# Connect to the database
conn = sqlite3.connect('sqlproject1.db')

# Query to calculate price difference
query_price_difference = '''
SELECT
    product_name,
    (original_price - selling_price) AS price_difference
FROM
    product1;
'''

df_price_difference = pd.read_sql_query(query_price_difference, conn)
conn.close()

# Horizontal bar chart for price difference
plt.figure(figsize=(12, 8))
sns.barplot(x='price_difference', y='product_name', data=df_price_difference, palette='crest')
plt.xlabel('Price Difference')
plt.ylabel('Product Name')
plt.title('Price Difference Between Original and Selling Prices')
plt.show()

"""# **Sales Analysis:**
# **Q16 Calculate total revenue generated from orders product wise.**
"""

# Connect to the database
conn = sqlite3.connect('sqlproject1.db')

# Query to get sales by product sub-category
query_sales_by_sub_category = '''
SELECT
    p.sub_category,
    SUM(o.total_price) AS total_revenue
FROM
    order_details1 o
JOIN
    product1 p ON o.product_id = p.product_id
GROUP BY
    p.sub_category
HAVING
    SUM(o.total_price) > 0
ORDER BY
    total_revenue DESC;
'''

# Load data into a DataFrame
df_sales_by_sub_category = pd.read_sql_query(query_sales_by_sub_category, conn)

# Close the connection
conn.close()

# Check if DataFrame is not empty
if not df_sales_by_sub_category.empty:
    # Visualization: Bar chart for sales by product sub-category
    plt.figure(figsize=(12, 8))
    sns.barplot(x='total_revenue', y='sub_category', data=df_sales_by_sub_category, palette='cubehelix')
    plt.xlabel('Total Revenue')
    plt.ylabel('Product Sub-Category')
    plt.title('Sales by Product Sub-Category')
    plt.show()
else:
    print("No data available for sales by product sub-category.")

"""# **Q17 Shows the distribution of revenue by different payment modes**"""

# Connect to the SQLite database
conn = sqlite3.connect('sqlproject1.db')

# Query to get revenue by payment mode
query_revenue_by_payment_mode = '''
SELECT
    payment_mode,
    SUM(total_price) AS total_revenue
FROM
    order_details1
GROUP BY
    payment_mode
ORDER BY
    total_revenue DESC;
'''

# Load data into a DataFrame
df_revenue_by_payment_mode = pd.read_sql_query(query_revenue_by_payment_mode, conn)

# Close the connection
conn.close()

# Visualization: Bar chart for revenue by payment mode
plt.figure(figsize=(12, 8))
sns.barplot(x='total_revenue', y='payment_mode', data=df_revenue_by_payment_mode, palette='Set2')
plt.xlabel('Total Revenue')
plt.ylabel('Payment Mode')
plt.title('Revenue by Payment Mode')
plt.show()

